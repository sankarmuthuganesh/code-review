package com.iv.gravity.entity;

import java.io.File;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;
import org.eclipse.jgit.lib.Repository;
import com.iv.gravity.service.utilities.AuthorFind;
import com.iv.gravity.service.utilities.BlamesUsingCommits;
import com.iv.gravity.service.utilities.OptimusLogicToBugSeperation;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class FileUnit implements Serializable {

   static Logger logger = Logger.getLogger(FileUnit.class);

   private static final long CURRENT_VERSION = 0;

   public FileUnit(String absolutePath, String repository, String branch, String licenseGroup, String license, String subsystem, String epic,
      String gitConnectionURL, String gitHome, Repository repo, AuthorFind findAuthor, BlamesUsingCommits blameDetails) {

      this.repository = repository;
      this.branch = branch;
      this.isAutogenerated = false;
      this.licenseGroup = licenseGroup;
      this.license = license;
      this.subSystem = subsystem;
      this.epicName = epic;
      this.setAbsolutePath(absolutePath, repository, branch, gitHome, gitConnectionURL);
      // Makes DB Heavily Loaded
      // try {
      //
      // this.fileContents = FileUtils.readFileToByteArray(new File(absolutePath));
      // } catch (IOException e) {
      // // Cannot Read File
      // }
      // this.fileContents = new FileContents(new byte[0]);
      this.decideTypeOfFile(absolutePath);
      // To allow to skip if not necessary
      if (Objects.nonNull(repo)) {
         this.countNumberOfLines();
         this.getAuthor(absolutePath, findAuthor);
         this.getBlameDetails(gitHome, repo, blameDetails);
      }
   }

   public FileUnit() {

   }

   // --------------------REPOSITORY, BRANCH, LICENSE GROUP, LICENSE, SUBSYSTEM,
   // EPIC--------------------------------//
   // The repository the File belongs
   public String repository;

   // The branch the File belongs
   public String branch;

   // License Group - SCM,AC
   private String licenseGroup;

   // License - Procurement,Project
   private String license;

   // Subsystem
   private String subSystem;

   // EpicName
   private String epicName;

   // --------------------FILES DETAILS--------------------------------//
   // Git URL Path
   private String remotePath;

   // Local Absolute Path where File exists - Usually the %temp% folder
   public String absolutePath;

   // File Name
   private String fileName;

   // Cobalt File or Not
   private boolean isAutogenerated = false;

   // Author of the File - @author mentioned
   private String authorOfFile;

   // Type of File(Java, Js, XML, LESS,CSS)
   private String natureOfFile = StringUtils.EMPTY;

   // Number of Lines in the File.
   private int numberOfLines;

   // private FileContents fileContents;

   // --------------------BUG DETAILS--------------------------------//
   // Catgory,Bug,LineNumber
   private List<BugDetails> bugDetailsList = new ArrayList<>();

   // Total Errors
   private int totalBugs;

   // Critical Bugs
   private int criticalBugs;

   // Major Bugs
   private int majorBugs;

   // Minor Bugs
   private int minorBugs;

   // -------FROM COMMIT LOG---------//
   private List<BlameDetails> blamesOfTheFile = new ArrayList<>();

   // FileContents
   private byte[] fileContents;

   // Search String and Line Numbers
   private Map<String, List<String>> searchStringLineNos = new HashMap<>();

   /*
    * Author of a file is Manipulated if it Java or JavaScript File
    */
   private void getAuthor(String absolutePath, AuthorFind findAuthor) {
      // if (natureOfFile.equals("Java")) {
      // JavaAuthor java = new JavaAuthor();
      // this.authorOfFile = java.getJavaAuthor(absolutePath);
      // if (this.authorOfFile.equals("ToolGenerated")) {
      // this.isAutogenerated = true;
      // this.authorOfFile = "NoAuthor";
      // }
      // } else if (natureOfFile.equals("JavaScript")) {
      // JsAuthor js = new JsAuthor();
      // this.authorOfFile = js.getJsAuthor(absolutePath);
      // } else {
      // // No Author Manipulation can be done!.
      // // Because they dont contain author.
      // this.authorOfFile = "NoAuthor";
      // }

      try {
         this.authorOfFile = findAuthor.getAuthor(absolutePath);
      }
      catch (IOException e) {
         this.authorOfFile = "NoAuthor";
      }
   }

   /*
    * setAbsolutePath sets the AbsolutePath. It calculates fileName licenseGroup TypeOfFile
    */
   public void setAbsolutePath(String absolutePath, String repository, String branch, String gitHome, String gitConnectionURL) {
      this.absolutePath = absolutePath;
      String fileName = new File(absolutePath).getName();
      this.fileName = fileName;
      // Because this approach is not portable. So another approach is followed.
      /*
       * Assumption: StringUtils.ordinalIndexOf(absolutePath, "/", 7) - The Branch is Cloned in %temp% folder. C:\Users
       * \sankraja\AppData\Local\Temp\river-2042580735792076063\hue-scm-project-biz\src\ main\java\com\worksap\company
       * \hue\scm\biz\project\approvalflow\listener\cost-profit-list-header.js It is replaced until 7th \
       */
      // this.httpPath=(absolutePath.replace(absolutePath.substring(0,
      // StringUtils.ordinalIndexOf(absolutePath, "\\",
      // 7)), "http://192.168.41.136/root/"+repository+"/blob/"+branch)).replace("\\",
      // "/");
      // May be the below alternative approach (gitHomeFolderPath) is to the point.
      // this.httpPath=(absolutePath.replace(absolutePath.substring(0,
      // absolutePath.indexOf(branch)+branch.length()),
      // this.life.getGitConnection()+"root/"+repository+"/blob/"+branch)).replace(File.separator,
      // "/");
      // String gitHomeFolderPath = new FolderIteratorFinder().getGitHome(absolutePath);

      // Patch for server absolutePath
      // String afterGravityFolder =
      // absolutePath.substring(absolutePath.indexOf("Gravity"));
      // int index;
      // if (afterGravityFolder.contains(File.separator)) {
      // index = StringUtils.ordinalIndexOf(afterGravityFolder, File.separator, 3);
      // afterGravityFolder = afterGravityFolder.replace(File.separator, "/");
      // } else if (afterGravityFolder.contains("/")) {
      // index = StringUtils.ordinalIndexOf(afterGravityFolder, "/", 3);
      // } else {
      // index = StringUtils.ordinalIndexOf(afterGravityFolder, "\\", 3);
      // afterGravityFolder = afterGravityFolder.replace("\\", "/");
      // }
      //
      // String filePath = afterGravityFolder.substring(index + 1);
      //
      // this.httpPath = this.gitConnectionURL
      // + "root/"
      // + repository
      // + "/blob/"
      // + branch
      // + "/" + filePath;
      this.remotePath = (absolutePath.replace(gitHome, gitConnectionURL + "root/" + repository + "/blob/" + branch));
      this.remotePath = StringUtils.replace(this.remotePath, File.separator, "/");
   }

   private void countNumberOfLines() {
      try {
         this.numberOfLines = Files.readAllLines(Paths.get(this.absolutePath)).size();
      }
      catch (Exception e) {
         logger.error("Malformed File", e);
         // Cannot Caluculate Number of Lines.
      }
      // FileInputStream input;
      // String result = null;
      // try {
      // input = new FileInputStream(new File(absolutePath));
      // CharsetDecoder decoder = Charset.forName("UTF-8").newDecoder();
      // decoder.onMalformedInput(CodingErrorAction.IGNORE);
      // InputStreamReader reader = new InputStreamReader(input, decoder);
      // BufferedReader bufferedReader = new BufferedReader( reader );
      // String line = bufferedReader.readLine();
      // while( line != null ) {
      //
      // }
      // bufferedReader.close();
      //
      // } catch (FileNotFoundException e) {
      // } catch( IOException e ) {
      // }
   }

   private void decideTypeOfFile(String pathOfFile) {
      // Have to modify - capitalise last string after dot, hence all file formats will be known
      if (pathOfFile.endsWith(".java")) {
         this.natureOfFile = "Java";
      }
      else if (pathOfFile.endsWith(".js")) {
         this.natureOfFile = "JavaScript";
      }
      else if (pathOfFile.endsWith(".xml")) {
         this.natureOfFile = "XML";
         // } else if (pathOfFile.endsWith(".less")) {
         // this.natureOfFile = "Less";
         // } else if (pathOfFile.endsWith(".css")) {
         // this.natureOfFile = "CSS";
         // } else if (pathOfFile.endsWith(".jsp")) {
         // this.natureOfFile = "JSP";
      }
      else {
         this.natureOfFile = StringUtils.capitalize(pathOfFile.substring(pathOfFile.lastIndexOf(".") + 1));
      }
   }

   public void setOptimusBugs(OptimusBugsOfAFile optimusBugs) {
      this.makeBugDetailsFromOptimus(optimusBugs);
   }

   public void makeBugDetailsFromOptimus(OptimusBugsOfAFile optimusBugs) {
      this.bugDetailsList = new OptimusLogicToBugSeperation().makeLineNumberAndCorrespodingBugDetails(optimusBugs, this.absolutePath, this.remotePath,
         this.fileName);
   }

   private void getBlameDetails(String gitHome, Repository repo, BlamesUsingCommits blameDetails) {
      // Commented Because a better approach to get details of the file is got - blame
      // this.authorsOfCommit=new
      // DetailsUsingCommits().getCommitDetails(this.absolutePath);
      try {
         this.blamesOfTheFile = blameDetails.getBlameDetails(this.absolutePath, gitHome, repo);
      }
      catch (Exception e) {
         // Cannot Find Blame Details
      }
   }

   // Serialization For Storing in Session (File Contents Omitted)
   public void writeObject(ObjectOutputStream output) throws IOException {
      output.writeLong(CURRENT_VERSION);
      output.writeUTF(repository);
      output.writeUTF(branch);
      output.writeUTF(licenseGroup);
      output.writeUTF(license);
      output.writeUTF(subSystem);
      output.writeUTF(epicName);
      output.writeUTF(remotePath);
      output.writeUTF(absolutePath);
      output.writeUTF(fileName);
      output.writeBoolean(isAutogenerated);
      output.writeUTF(authorOfFile);
      output.writeUTF(natureOfFile);
      output.writeInt(numberOfLines);
      output.writeObject(bugDetailsList);
      output.writeInt(totalBugs);
      output.writeInt(criticalBugs);
      output.writeInt(majorBugs);
      output.writeInt(minorBugs);
      output.writeObject(blamesOfTheFile);
      output.writeObject(searchStringLineNos);
   }

   public void readObject(ObjectInputStream input) throws ClassNotFoundException, IOException {
      long currentVersion = input.readLong();
      if (currentVersion == 0) {
         this.repository = input.readUTF();
         this.branch = input.readUTF();
         this.licenseGroup = input.readUTF();
         this.license = input.readUTF();
         this.subSystem = input.readUTF();
         this.epicName = input.readUTF();
         this.remotePath = input.readUTF();
         this.absolutePath = input.readUTF();
         this.fileName = input.readUTF();
         this.isAutogenerated = input.readBoolean();
         this.authorOfFile = input.readUTF();
         this.natureOfFile = input.readUTF();
         this.numberOfLines = input.readInt();
         this.bugDetailsList = (List<BugDetails>) input.readObject();
         this.totalBugs = input.readInt();
         this.criticalBugs = input.readInt();
         this.majorBugs = input.readInt();
         this.minorBugs = input.readInt();
         this.blamesOfTheFile = (List<BlameDetails>) input.readObject();
         this.searchStringLineNos = (Map<String, List<String>>) input.readObject();
      }
   }

}
